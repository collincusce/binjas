{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap d9e14e063ff80ea3d620","webpack:///./src/index.js","webpack:///./node_modules/binary-parser/lib/binary_parser.js","webpack:///./node_modules/vm-browserify/index.js","webpack:///./node_modules/indexof/index.js","webpack:///./node_modules/binary-parser/lib/context.js"],"names":["binjas"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;;;;AC7DA;;AAEA,IAAMA,SAAS,0BAAf;;QAEQA,M,GAAAA,M;;;;;;ACJR;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC,iBAAiB;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,+CAA+C;AAC/C;AACA,iBAAiB;;AAEjB;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,0BAA0B,EAAE,WAAW;AACvC,GAAG;AACH,8BAA8B;AAC9B;;AAEA;AACA;;AAEA;AACA,+BAA+B;;AAE/B;AACA,iDAAiD;AACjD,GAAG;AACH,gCAAgC;AAChC;;AAEA;;AAEA;;AAEA,4BAA4B;AAC5B;;AAEA;AACA,0BAA0B,EAAE,UAAU;;AAEtC;AACA,iDAAiD;AACjD,GAAG;AACH,gCAAgC;AAChC;;AAEA;;AAEA;AACA;;AAEA,wBAAwB,gCAAgC;AACxD,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,+CAA+C,yBAAyB;AACxE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,G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ChC;;AAEA,iBAAiB;;AAEjB;AACA;AACA,kBAAkB,EAAE,cAAc,EAAE,yBAAyB;AAC7D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,EAAE,eAAe,EAAE,SAAS;AACtC;AACA;AACA;AACA,+BAA+B,GAAG;AAClC,KAAK;AACL;AACA,yBAAyB,EAAE,IAAI,EAAE,SAAS;AAC1C;AACA,UAAU,EAAE,IAAI,EAAE,QAAQ,WAAW,EAAE,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,EAAE,MAAM;AAC3B;AACA,wBAAwB,EAAE,GAAG;AAC7B;AACA;;AAEA,wBAAwB,EAAE;AAC1B;AACA,wBAAwB;AACxB,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH,qDAAqD,EAAE;AACvD;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB,EAAE,MAAM;AAC7B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,YAAY,EAAE,IAAI,EAAE,SAAS;AAC7B;AACA;AACA;AACA,mBAAmB,EAAE,IAAI,EAAE,QAAQ,WAAW,EAAE,QAAQ;AACxD;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,EAAE,KAAK,EAAE,cAAc,EAAE,EAAE;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;AC5uBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;ACxIA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA,E;;;;;;ACTA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C;AAC3C;AACA,kBAAkB,EAAE,EAAE;AACtB;AACA,GAAG;AACH,gDAAgD;AAChD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,IAAI;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA","file":"binjas.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"binjas\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"binjas\"] = factory();\n\telse\n\t\troot[\"binjas\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d9e14e063ff80ea3d620","import {Parser as BinaryParser} from 'binary-parser';\n\nconst binjas = new BinaryParser();\n\nexport {binjas};\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","//========================================================================================\n// Globals\n//========================================================================================\nvar vm = require(\"vm\");\n\nvar Context = require(\"./context\").Context;\n\nvar PRIMITIVE_TYPES = {\n  UInt8: 1,\n  UInt16LE: 2,\n  UInt16BE: 2,\n  UInt32LE: 4,\n  UInt32BE: 4,\n  Int8: 1,\n  Int16LE: 2,\n  Int16BE: 2,\n  Int32LE: 4,\n  Int32BE: 4,\n  FloatLE: 4,\n  FloatBE: 4,\n  DoubleLE: 8,\n  DoubleBE: 8\n};\n\nvar SPECIAL_TYPES = {\n  String: null,\n  Buffer: null,\n  Array: null,\n  Skip: null,\n  Choice: null,\n  Nest: null,\n  Bit: null\n};\n\nvar aliasRegistry = {};\nvar FUNCTION_PREFIX = \"___parser_\";\n\nvar BIT_RANGE = [];\n(function() {\n  var i;\n  for (i = 1; i <= 32; i++) {\n    BIT_RANGE.push(i);\n  }\n})();\n\n// Converts Parser's method names to internal type names\nvar NAME_MAP = {};\nObject.keys(PRIMITIVE_TYPES)\n  .concat(Object.keys(SPECIAL_TYPES))\n  .forEach(function(type) {\n    NAME_MAP[type.toLowerCase()] = type;\n  });\n\n//========================================================================================\n// class Parser\n//========================================================================================\n\n//----------------------------------------------------------------------------------------\n// constructor\n//----------------------------------------------------------------------------------------\n\nvar Parser = function() {\n  this.varName = \"\";\n  this.type = \"\";\n  this.options = {};\n  this.next = null;\n  this.head = null;\n  this.compiled = null;\n  this.endian = \"be\";\n  this.constructorFn = null;\n  this.alias = null;\n};\n\n//----------------------------------------------------------------------------------------\n// public methods\n//----------------------------------------------------------------------------------------\n\nParser.start = function() {\n  return new Parser();\n};\n\nObject.keys(PRIMITIVE_TYPES).forEach(function(type) {\n  Parser.prototype[type.toLowerCase()] = function(varName, options) {\n    return this.setNextParser(type.toLowerCase(), varName, options);\n  };\n\n  var typeWithoutEndian = type.replace(/BE|LE/, \"\").toLowerCase();\n  if (!(typeWithoutEndian in Parser.prototype)) {\n    Parser.prototype[typeWithoutEndian] = function(varName, options) {\n      return this[typeWithoutEndian + this.endian](varName, options);\n    };\n  }\n});\n\nBIT_RANGE.forEach(function(i) {\n  Parser.prototype[\"bit\" + i.toString()] = function(varName, options) {\n    if (!options) {\n      options = {};\n    }\n    options.length = i;\n    return this.setNextParser(\"bit\", varName, options);\n  };\n});\n\nParser.prototype.namely = function(alias) {\n  aliasRegistry[alias] = this;\n  this.alias = alias;\n  return this;\n};\n\nParser.prototype.skip = function(length, options) {\n  if (options && options.assert) {\n    throw new Error(\"assert option on skip is not allowed.\");\n  }\n\n  return this.setNextParser(\"skip\", \"\", { length: length });\n};\n\nParser.prototype.string = function(varName, options) {\n  if (!options.zeroTerminated && !options.length && !options.greedy) {\n    throw new Error(\n      \"Neither length, zeroTerminated, nor greedy is defined for string.\"\n    );\n  }\n  if ((options.zeroTerminated || options.length) && options.greedy) {\n    throw new Error(\n      \"greedy is mutually exclusive with length and zeroTerminated for string.\"\n    );\n  }\n  if (options.stripNull && !(options.length || options.greedy)) {\n    throw new Error(\n      \"Length or greedy must be defined if stripNull is defined.\"\n    );\n  }\n  options.encoding = options.encoding || \"utf8\";\n\n  return this.setNextParser(\"string\", varName, options);\n};\n\nParser.prototype.buffer = function(varName, options) {\n  if (!options.length && !options.readUntil) {\n    throw new Error(\"Length nor readUntil is defined in buffer parser\");\n  }\n\n  return this.setNextParser(\"buffer\", varName, options);\n};\n\nParser.prototype.array = function(varName, options) {\n  if (!options.readUntil && !options.length && !options.lengthInBytes) {\n    throw new Error(\"Length option of array is not defined.\");\n  }\n  if (!options.type) {\n    throw new Error(\"Type option of array is not defined.\");\n  }\n  if (\n    typeof options.type === \"string\" &&\n    !aliasRegistry[options.type] &&\n    Object.keys(PRIMITIVE_TYPES).indexOf(NAME_MAP[options.type]) < 0\n  ) {\n    throw new Error(\n      'Specified primitive type \"' + options.type + '\" is not supported.'\n    );\n  }\n\n  return this.setNextParser(\"array\", varName, options);\n};\n\nParser.prototype.choice = function(varName, options) {\n  if (arguments.length == 1 && typeof varName === \"object\") {\n    options = varName;\n    varName = null;\n  }\n\n  if (!options.tag) {\n    throw new Error(\"Tag option of array is not defined.\");\n  }\n  if (!options.choices) {\n    throw new Error(\"Choices option of array is not defined.\");\n  }\n\n  Object.keys(options.choices).forEach(function(key) {\n    if (isNaN(parseInt(key, 10))) {\n      throw new Error(\"Key of choices must be a number.\");\n    }\n    if (!options.choices[key]) {\n      throw new Error(\n        \"Choice Case \" + key + \" of \" + varName + \" is not valid.\"\n      );\n    }\n\n    if (\n      typeof options.choices[key] === \"string\" &&\n      !aliasRegistry[options.choices[key]] &&\n      Object.keys(PRIMITIVE_TYPES).indexOf(NAME_MAP[options.choices[key]]) < 0\n    ) {\n      throw new Error(\n        'Specified primitive type \"' +\n          options.choices[key] +\n          '\" is not supported.'\n      );\n    }\n  }, this);\n\n  return this.setNextParser(\"choice\", varName, options);\n};\n\nParser.prototype.nest = function(varName, options) {\n  if (arguments.length == 1 && typeof varName === \"object\") {\n    options = varName;\n    varName = null;\n  }\n\n  if (!options.type) {\n    throw new Error(\"Type option of nest is not defined.\");\n  }\n  if (!(options.type instanceof Parser) && !aliasRegistry[options.type]) {\n    throw new Error(\"Type option of nest must be a Parser object.\");\n  }\n  if (!(options.type instanceof Parser) && !varName) {\n    throw new Error(\n      \"options.type must be a object if variable name is omitted.\"\n    );\n  }\n\n  return this.setNextParser(\"nest\", varName, options);\n};\n\nParser.prototype.endianess = function(endianess) {\n  switch (endianess.toLowerCase()) {\n    case \"little\":\n      this.endian = \"le\";\n      break;\n    case \"big\":\n      this.endian = \"be\";\n      break;\n    default:\n      throw new Error(\"Invalid endianess: \" + endianess);\n  }\n\n  return this;\n};\n\nParser.prototype.create = function(constructorFn) {\n  if (!(constructorFn instanceof Function)) {\n    throw new Error(\"Constructor must be a Function object.\");\n  }\n\n  this.constructorFn = constructorFn;\n\n  return this;\n};\n\nParser.prototype.getCode = function() {\n  var ctx = new Context();\n\n  ctx.pushCode(\"if (!Buffer.isBuffer(buffer)) {\");\n  ctx.generateError('\"argument buffer is not a Buffer object\"');\n  ctx.pushCode(\"}\");\n\n  if (!this.alias) {\n    this.addRawCode(ctx);\n  } else {\n    this.addAliasedCode(ctx);\n  }\n\n  if (this.alias) {\n    ctx.pushCode(\"return {0}(0).result;\", FUNCTION_PREFIX + this.alias);\n  } else {\n    ctx.pushCode(\"return vars;\");\n  }\n\n  return ctx.code;\n};\n\nParser.prototype.addRawCode = function(ctx) {\n  ctx.pushCode(\"var offset = 0;\");\n\n  if (this.constructorFn) {\n    ctx.pushCode(\"var vars = new constructorFn();\");\n  } else {\n    ctx.pushCode(\"var vars = {};\");\n  }\n\n  this.generate(ctx);\n\n  this.resolveReferences(ctx);\n\n  ctx.pushCode(\"return vars;\");\n};\n\nParser.prototype.addAliasedCode = function(ctx) {\n  ctx.pushCode(\"function {0}(offset) {\", FUNCTION_PREFIX + this.alias);\n\n  if (this.constructorFn) {\n    ctx.pushCode(\"var vars = new constructorFn();\");\n  } else {\n    ctx.pushCode(\"var vars = {};\");\n  }\n\n  this.generate(ctx);\n\n  ctx.markResolved(this.alias);\n  this.resolveReferences(ctx);\n\n  ctx.pushCode(\"return { offset: offset, result: vars };\");\n  ctx.pushCode(\"}\");\n\n  return ctx;\n};\n\nParser.prototype.resolveReferences = function(ctx) {\n  var references = ctx.getUnresolvedReferences();\n  ctx.markRequested(references);\n  references.forEach(function(alias) {\n    var parser = aliasRegistry[alias];\n    parser.addAliasedCode(ctx);\n  });\n};\n\nParser.prototype.compile = function() {\n  var src = \"(function(buffer, constructorFn) { \" + this.getCode() + \" })\";\n  this.compiled = vm.runInThisContext(src);\n};\n\nParser.prototype.sizeOf = function() {\n  var size = NaN;\n\n  if (Object.keys(PRIMITIVE_TYPES).indexOf(this.type) >= 0) {\n    size = PRIMITIVE_TYPES[this.type];\n\n    // if this is a fixed length string\n  } else if (\n    this.type === \"String\" &&\n    typeof this.options.length === \"number\"\n  ) {\n    size = this.options.length;\n\n    // if this is a fixed length buffer\n  } else if (\n    this.type === \"Buffer\" &&\n    typeof this.options.length === \"number\"\n  ) {\n    size = this.options.length;\n\n    // if this is a fixed length array\n  } else if (this.type === \"Array\" && typeof this.options.length === \"number\") {\n    var elementSize = NaN;\n    if (typeof this.options.type === \"string\") {\n      elementSize = PRIMITIVE_TYPES[NAME_MAP[this.options.type]];\n    } else if (this.options.type instanceof Parser) {\n      elementSize = this.options.type.sizeOf();\n    }\n    size = this.options.length * elementSize;\n\n    // if this a skip\n  } else if (this.type === \"Skip\") {\n    size = this.options.length;\n\n    // if this is a nested parser\n  } else if (this.type === \"Nest\") {\n    size = this.options.type.sizeOf();\n  } else if (!this.type) {\n    size = 0;\n  }\n\n  if (this.next) {\n    size += this.next.sizeOf();\n  }\n\n  return size;\n};\n\n// Follow the parser chain till the root and start parsing from there\nParser.prototype.parse = function(buffer) {\n  if (!this.compiled) {\n    this.compile();\n  }\n\n  return this.compiled(buffer, this.constructorFn);\n};\n\n//----------------------------------------------------------------------------------------\n// private methods\n//----------------------------------------------------------------------------------------\n\nParser.prototype.setNextParser = function(type, varName, options) {\n  var parser = new Parser();\n\n  parser.type = NAME_MAP[type];\n  parser.varName = varName;\n  parser.options = options || parser.options;\n  parser.endian = this.endian;\n\n  if (this.head) {\n    this.head.next = parser;\n  } else {\n    this.next = parser;\n  }\n  this.head = parser;\n\n  return this;\n};\n\n// Call code generator for this parser\nParser.prototype.generate = function(ctx) {\n  if (this.type) {\n    this[\"generate\" + this.type](ctx);\n    this.generateAssert(ctx);\n  }\n\n  var varName = ctx.generateVariable(this.varName);\n  if (this.options.formatter) {\n    this.generateFormatter(ctx, varName, this.options.formatter);\n  }\n\n  return this.generateNext(ctx);\n};\n\nParser.prototype.generateAssert = function(ctx) {\n  if (!this.options.assert) {\n    return;\n  }\n\n  var varName = ctx.generateVariable(this.varName);\n\n  switch (typeof this.options.assert) {\n    case \"function\":\n      ctx.pushCode(\n        \"if (!({0}).call(vars, {1})) {\",\n        this.options.assert,\n        varName\n      );\n      break;\n    case \"number\":\n      ctx.pushCode(\"if ({0} !== {1}) {\", this.options.assert, varName);\n      break;\n    case \"string\":\n      ctx.pushCode('if (\"{0}\" !== {1}) {', this.options.assert, varName);\n      break;\n    default:\n      throw new Error(\n        \"Assert option supports only strings, numbers and assert functions.\"\n      );\n  }\n  ctx.generateError('\"Assert error: {0} is \" + {0}', varName);\n  ctx.pushCode(\"}\");\n};\n\n// Recursively call code generators and append results\nParser.prototype.generateNext = function(ctx) {\n  if (this.next) {\n    ctx = this.next.generate(ctx);\n  }\n\n  return ctx;\n};\n\nObject.keys(PRIMITIVE_TYPES).forEach(function(type) {\n  Parser.prototype[\"generate\" + type] = function(ctx) {\n    ctx.pushCode(\n      \"{0} = buffer.read{1}(offset);\",\n      ctx.generateVariable(this.varName),\n      type\n    );\n    ctx.pushCode(\"offset += {0};\", PRIMITIVE_TYPES[type]);\n  };\n});\n\nParser.prototype.generateBit = function(ctx) {\n  // TODO find better method to handle nested bit fields\n  var parser = JSON.parse(JSON.stringify(this));\n  parser.varName = ctx.generateVariable(parser.varName);\n  ctx.bitFields.push(parser);\n\n  if (\n    !this.next ||\n    (this.next && [\"Bit\", \"Nest\"].indexOf(this.next.type) < 0)\n  ) {\n    var sum = 0;\n    ctx.bitFields.forEach(function(parser) {\n      sum += parser.options.length;\n    });\n\n    var val = ctx.generateTmpVariable();\n\n    if (sum <= 8) {\n      ctx.pushCode(\"var {0} = buffer.readUInt8(offset);\", val);\n      sum = 8;\n    } else if (sum <= 16) {\n      ctx.pushCode(\"var {0} = buffer.readUInt16BE(offset);\", val);\n      sum = 16;\n    } else if (sum <= 24) {\n      var val1 = ctx.generateTmpVariable();\n      var val2 = ctx.generateTmpVariable();\n      ctx.pushCode(\"var {0} = buffer.readUInt16BE(offset);\", val1);\n      ctx.pushCode(\"var {0} = buffer.readUInt8(offset + 2);\", val2);\n      ctx.pushCode(\"var {2} = ({0} << 8) | {1};\", val1, val2, val);\n      sum = 24;\n    } else if (sum <= 32) {\n      ctx.pushCode(\"var {0} = buffer.readUInt32BE(offset);\", val);\n      sum = 32;\n    } else {\n      throw new Error(\n        \"Currently, bit field sequence longer than 4-bytes is not supported.\"\n      );\n    }\n    ctx.pushCode(\"offset += {0};\", sum / 8);\n\n    var bitOffset = 0;\n    var isBigEndian = this.endian === \"be\";\n    ctx.bitFields.forEach(function(parser) {\n      ctx.pushCode(\n        \"{0} = {1} >> {2} & {3};\",\n        parser.varName,\n        val,\n        isBigEndian ? sum - bitOffset - parser.options.length : bitOffset,\n        (1 << parser.options.length) - 1\n      );\n      bitOffset += parser.options.length;\n    });\n\n    ctx.bitFields = [];\n  }\n};\n\nParser.prototype.generateSkip = function(ctx) {\n  var length = ctx.generateOption(this.options.length);\n  ctx.pushCode(\"offset += {0};\", length);\n};\n\nParser.prototype.generateString = function(ctx) {\n  var name = ctx.generateVariable(this.varName);\n  var start = ctx.generateTmpVariable();\n\n  if (this.options.length && this.options.zeroTerminated) {\n    ctx.pushCode(\"var {0} = offset;\", start);\n    ctx.pushCode(\n      \"while(buffer.readUInt8(offset++) !== 0 && offset - {0}  < {1});\",\n      start,\n      this.options.length\n    );\n    ctx.pushCode(\n      \"{0} = buffer.toString('{1}', {2}, offset - {2} < {3} ? offset - 1 : offset);\",\n      name,\n      this.options.encoding,\n      start,\n      this.options.length\n    );\n  } else if (this.options.length) {\n    ctx.pushCode(\n      \"{0} = buffer.toString('{1}', offset, offset + {2});\",\n      name,\n      this.options.encoding,\n      ctx.generateOption(this.options.length)\n    );\n    ctx.pushCode(\"offset += {0};\", ctx.generateOption(this.options.length));\n  } else if (this.options.zeroTerminated) {\n    ctx.pushCode(\"var {0} = offset;\", start);\n    ctx.pushCode(\"while(buffer.readUInt8(offset++) !== 0);\");\n    ctx.pushCode(\n      \"{0} = buffer.toString('{1}', {2}, offset - 1);\",\n      name,\n      this.options.encoding,\n      start\n    );\n  } else if (this.options.greedy) {\n    ctx.pushCode(\"var {0} = offset;\", start);\n    ctx.pushCode(\"while(buffer.length > offset++);\");\n    ctx.pushCode(\n      \"{0} = buffer.toString('{1}', {2}, offset);\",\n      name,\n      this.options.encoding,\n      start\n    );\n  }\n  if (this.options.stripNull) {\n    ctx.pushCode(\"{0} = {0}.replace(/\\\\x00+$/g, '')\", name);\n  }\n};\n\nParser.prototype.generateBuffer = function(ctx) {\n  if (this.options.readUntil === \"eof\") {\n    ctx.pushCode(\n      \"{0} = buffer.slice(offset);\",\n      ctx.generateVariable(this.varName)\n    );\n  } else {\n    ctx.pushCode(\n      \"{0} = buffer.slice(offset, offset + {1});\",\n      ctx.generateVariable(this.varName),\n      ctx.generateOption(this.options.length)\n    );\n    ctx.pushCode(\"offset += {0};\", ctx.generateOption(this.options.length));\n  }\n\n  if (this.options.clone) {\n    ctx.pushCode(\"{0} = Buffer.from({0});\", ctx.generateVariable(this.varName));\n  }\n};\n\nParser.prototype.generateArray = function(ctx) {\n  var length = ctx.generateOption(this.options.length);\n  var lengthInBytes = ctx.generateOption(this.options.lengthInBytes);\n  var type = this.options.type;\n  var counter = ctx.generateTmpVariable();\n  var lhs = ctx.generateVariable(this.varName);\n  var item = ctx.generateTmpVariable();\n  var key = this.options.key;\n  var isHash = typeof key === \"string\";\n\n  if (isHash) {\n    ctx.pushCode(\"{0} = {};\", lhs);\n  } else {\n    ctx.pushCode(\"{0} = [];\", lhs);\n  }\n  if (typeof this.options.readUntil === \"function\") {\n    ctx.pushCode(\"do {\");\n  } else if (this.options.readUntil === \"eof\") {\n    ctx.pushCode(\"for (var {0} = 0; offset < buffer.length; {0}++) {\", counter);\n  } else if (lengthInBytes !== undefined) {\n    ctx.pushCode(\n      \"for (var {0} = offset; offset - {0} < {1}; ) {\",\n      counter,\n      lengthInBytes\n    );\n  } else {\n    ctx.pushCode(\"for (var {0} = 0; {0} < {1}; {0}++) {\", counter, length);\n  }\n\n  if (typeof type === \"string\") {\n    if (!aliasRegistry[type]) {\n      ctx.pushCode(\"var {0} = buffer.read{1}(offset);\", item, NAME_MAP[type]);\n      ctx.pushCode(\"offset += {0};\", PRIMITIVE_TYPES[NAME_MAP[type]]);\n    } else {\n      var tempVar = ctx.generateTmpVariable();\n      ctx.pushCode(\"var {0} = {1}(offset);\", tempVar, FUNCTION_PREFIX + type);\n      ctx.pushCode(\"var {0} = {1}.result; offset = {1}.offset;\", item, tempVar);\n      if (type !== this.alias) ctx.addReference(type);\n    }\n  } else if (type instanceof Parser) {\n    ctx.pushCode(\"var {0} = {};\", item);\n\n    ctx.pushScope(item);\n    type.generate(ctx);\n    ctx.popScope();\n  }\n\n  if (isHash) {\n    ctx.pushCode(\"{0}[{2}.{1}] = {2};\", lhs, key, item);\n  } else {\n    ctx.pushCode(\"{0}.push({1});\", lhs, item);\n  }\n\n  ctx.pushCode(\"}\");\n\n  if (typeof this.options.readUntil === \"function\") {\n    ctx.pushCode(\n      \" while (!({0}).call(this, {1}, buffer.slice(offset)));\",\n      this.options.readUntil,\n      item\n    );\n  }\n};\n\nParser.prototype.generateChoiceCase = function(ctx, varName, type) {\n  if (typeof type === \"string\") {\n    if (!aliasRegistry[type]) {\n      ctx.pushCode(\n        \"{0} = buffer.read{1}(offset);\",\n        ctx.generateVariable(this.varName),\n        NAME_MAP[type]\n      );\n      ctx.pushCode(\"offset += {0};\", PRIMITIVE_TYPES[NAME_MAP[type]]);\n    } else {\n      var tempVar = ctx.generateTmpVariable();\n      ctx.pushCode(\"var {0} = {1}(offset);\", tempVar, FUNCTION_PREFIX + type);\n      ctx.pushCode(\n        \"{0} = {1}.result; offset = {1}.offset;\",\n        ctx.generateVariable(this.varName),\n        tempVar\n      );\n      if (type !== this.alias) ctx.addReference(type);\n    }\n  } else if (type instanceof Parser) {\n    ctx.pushPath(varName);\n    type.generate(ctx);\n    ctx.popPath(varName);\n  }\n};\n\nParser.prototype.generateChoice = function(ctx) {\n  var tag = ctx.generateOption(this.options.tag);\n  if (this.varName) {\n    ctx.pushCode(\"{0} = {};\", ctx.generateVariable(this.varName));\n  }\n  ctx.pushCode(\"switch({0}) {\", tag);\n  Object.keys(this.options.choices).forEach(function(tag) {\n    var type = this.options.choices[tag];\n\n    ctx.pushCode(\"case {0}:\", tag);\n    this.generateChoiceCase(ctx, this.varName, type);\n    ctx.pushCode(\"break;\");\n  }, this);\n  ctx.pushCode(\"default:\");\n  if (this.options.defaultChoice) {\n    this.generateChoiceCase(ctx, this.varName, this.options.defaultChoice);\n  } else {\n    ctx.generateError('\"Met undefined tag value \" + {0} + \" at choice\"', tag);\n  }\n  ctx.pushCode(\"}\");\n};\n\nParser.prototype.generateNest = function(ctx) {\n  var nestVar = ctx.generateVariable(this.varName);\n\n  if (this.options.type instanceof Parser) {\n    if (this.varName) {\n      ctx.pushCode(\"{0} = {};\", nestVar);\n    }\n    ctx.pushPath(this.varName);\n    this.options.type.generate(ctx);\n    ctx.popPath(this.varName);\n  } else if (aliasRegistry[this.options.type]) {\n    var tempVar = ctx.generateTmpVariable();\n    ctx.pushCode(\n      \"var {0} = {1}(offset);\",\n      tempVar,\n      FUNCTION_PREFIX + this.options.type\n    );\n    ctx.pushCode(\"{0} = {1}.result; offset = {1}.offset;\", nestVar, tempVar);\n    if (this.options.type !== this.alias) ctx.addReference(this.options.type);\n  }\n};\n\nParser.prototype.generateFormatter = function(ctx, varName, formatter) {\n  if (typeof formatter === \"function\") {\n    ctx.pushCode(\"{0} = ({1}).call(this, {0});\", varName, formatter);\n  }\n};\n\nParser.prototype.isInteger = function() {\n  return !!this.type.match(/U?Int[8|16|32][BE|LE]?|Bit\\d+/);\n};\n\n//========================================================================================\n// Exports\n//========================================================================================\n\nexports.Parser = Parser;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/binary-parser/lib/binary_parser.js\n// module id = 1\n// module chunks = 0","var indexOf = require('indexof');\n\nvar Object_keys = function (obj) {\n    if (Object.keys) return Object.keys(obj)\n    else {\n        var res = [];\n        for (var key in obj) res.push(key)\n        return res;\n    }\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nvar defineProp = (function() {\n    try {\n        Object.defineProperty({}, '_', {});\n        return function(obj, name, value) {\n            Object.defineProperty(obj, name, {\n                writable: true,\n                enumerable: false,\n                configurable: true,\n                value: value\n            })\n        };\n    } catch(e) {\n        return function(obj, name, value) {\n            obj[name] = value;\n        };\n    }\n}());\n\nvar globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',\n'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',\n'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',\n'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',\n'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];\n\nfunction Context() {}\nContext.prototype = {};\n\nvar Script = exports.Script = function NodeScript (code) {\n    if (!(this instanceof Script)) return new Script(code);\n    this.code = code;\n};\n\nScript.prototype.runInContext = function (context) {\n    if (!(context instanceof Context)) {\n        throw new TypeError(\"needs a 'context' argument.\");\n    }\n    \n    var iframe = document.createElement('iframe');\n    if (!iframe.style) iframe.style = {};\n    iframe.style.display = 'none';\n    \n    document.body.appendChild(iframe);\n    \n    var win = iframe.contentWindow;\n    var wEval = win.eval, wExecScript = win.execScript;\n\n    if (!wEval && wExecScript) {\n        // win.eval() magically appears when this is called in IE:\n        wExecScript.call(win, 'null');\n        wEval = win.eval;\n    }\n    \n    forEach(Object_keys(context), function (key) {\n        win[key] = context[key];\n    });\n    forEach(globals, function (key) {\n        if (context[key]) {\n            win[key] = context[key];\n        }\n    });\n    \n    var winKeys = Object_keys(win);\n\n    var res = wEval.call(win, this.code);\n    \n    forEach(Object_keys(win), function (key) {\n        // Avoid copying circular objects like `top` and `window` by only\n        // updating existing context properties or new properties in the `win`\n        // that was only introduced after the eval.\n        if (key in context || indexOf(winKeys, key) === -1) {\n            context[key] = win[key];\n        }\n    });\n\n    forEach(globals, function (key) {\n        if (!(key in context)) {\n            defineProp(context, key, win[key]);\n        }\n    });\n    \n    document.body.removeChild(iframe);\n    \n    return res;\n};\n\nScript.prototype.runInThisContext = function () {\n    return eval(this.code); // maybe...\n};\n\nScript.prototype.runInNewContext = function (context) {\n    var ctx = Script.createContext(context);\n    var res = this.runInContext(ctx);\n\n    forEach(Object_keys(ctx), function (key) {\n        context[key] = ctx[key];\n    });\n\n    return res;\n};\n\nforEach(Object_keys(Script.prototype), function (name) {\n    exports[name] = Script[name] = function (code) {\n        var s = Script(code);\n        return s[name].apply(s, [].slice.call(arguments, 1));\n    };\n});\n\nexports.createScript = function (code) {\n    return exports.Script(code);\n};\n\nexports.createContext = Script.createContext = function (context) {\n    var copy = new Context();\n    if(typeof context === 'object') {\n        forEach(Object_keys(context), function (key) {\n            copy[key] = context[key];\n        });\n    }\n    return copy;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vm-browserify/index.js\n// module id = 2\n// module chunks = 0","\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/indexof/index.js\n// module id = 3\n// module chunks = 0","//========================================================================================\n// class Context\n//========================================================================================\n\n//----------------------------------------------------------------------------------------\n// constructor\n//----------------------------------------------------------------------------------------\n\nvar Context = function() {\n  this.code = \"\";\n  this.scopes = [[\"vars\"]];\n  this.isAsync = false;\n  this.bitFields = [];\n  this.tmpVariableCount = 0;\n  this.references = {};\n};\n\n//----------------------------------------------------------------------------------------\n// public methods\n//----------------------------------------------------------------------------------------\n\nContext.prototype.generateVariable = function(name) {\n  var arr = [];\n\n  Array.prototype.push.apply(arr, this.scopes[this.scopes.length - 1]);\n  if (name) {\n    arr.push(name);\n  }\n\n  return arr.join(\".\");\n};\n\nContext.prototype.generateOption = function(val) {\n  switch (typeof val) {\n    case \"number\":\n      return val.toString();\n    case \"string\":\n      return this.generateVariable(val);\n    case \"function\":\n      return \"(\" + val + \").call(\" + this.generateVariable() + \", vars)\";\n  }\n};\n\nContext.prototype.generateError = function() {\n  var args = Array.prototype.slice.call(arguments);\n  var err = Context.interpolate.apply(this, args);\n\n  if (this.isAsync) {\n    this.pushCode(\n      \"return process.nextTick(function() { callback(new Error(\" +\n        err +\n        \"), vars); });\"\n    );\n  } else {\n    this.pushCode(\"throw new Error(\" + err + \");\");\n  }\n};\n\nContext.prototype.generateTmpVariable = function() {\n  return \"$tmp\" + this.tmpVariableCount++;\n};\n\nContext.prototype.pushCode = function() {\n  var args = Array.prototype.slice.call(arguments);\n\n  this.code += Context.interpolate.apply(this, args) + \"\\n\";\n};\n\nContext.prototype.pushPath = function(name) {\n  if (name) {\n    this.scopes[this.scopes.length - 1].push(name);\n  }\n};\n\nContext.prototype.popPath = function(name) {\n  if (name) {\n    this.scopes[this.scopes.length - 1].pop();\n  }\n};\n\nContext.prototype.pushScope = function(name) {\n  this.scopes.push([name]);\n};\n\nContext.prototype.popScope = function() {\n  this.scopes.pop();\n};\n\nContext.prototype.addReference = function(alias) {\n  if (this.references[alias]) return;\n  this.references[alias] = { resolved: false, requested: false };\n};\n\nContext.prototype.markResolved = function(alias) {\n  this.references[alias].resolved = true;\n};\n\nContext.prototype.markRequested = function(aliasList) {\n  aliasList.forEach(\n    function(alias) {\n      this.references[alias].requested = true;\n    }.bind(this)\n  );\n};\n\nContext.prototype.getUnresolvedReferences = function() {\n  var references = this.references;\n  return Object.keys(this.references).filter(function(alias) {\n    return !references[alias].resolved && !references[alias].requested;\n  });\n};\n\n//----------------------------------------------------------------------------------------\n// private methods\n//----------------------------------------------------------------------------------------\n\nContext.interpolate = function(s) {\n  var re = /{\\d+}/g;\n  var matches = s.match(re);\n  var params = Array.prototype.slice.call(arguments, 1);\n\n  if (matches) {\n    matches.forEach(function(match) {\n      var index = parseInt(match.substr(1, match.length - 2), 10);\n      s = s.replace(match, params[index].toString());\n    });\n  }\n\n  return s;\n};\n\nexports.Context = Context;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/binary-parser/lib/context.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}